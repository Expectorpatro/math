\chapter{统计计算方法}

\section{非线性方程的求解}
\subsubsection{二分法}
\begin{method}[Bisection Method]
	设函数$f$在$[a,b]$上连续，且满足$f(a)f(b)<0$。为求解非线性方程$f(x)=0$，由\cref{lem:IntermediateValueR}可知，存在至少一个根$x^{\star}\in(a,b)$。二分法通过反复对区间进行二等分来逐步缩小根所在的区间：令：
	\begin{equation*}
		c=\frac{a+b}{2}
	\end{equation*}
	若$f(c)=0$，则$c$即为方程的解；否则根据符号判定准则，取满足：
	\begin{equation*}
		f(a)f(c)<0\quad\text{或}\quad f(c)f(b)<0
	\end{equation*}
	的子区间作为新的区间$[a,b]$，并重复上述过程。\par
	经过$n$次迭代后，所得区间长度不超过$(b-a)/2^n$，任意迭代点$x_n$与真根$x^{\star}$的误差满足：
	\begin{equation*}
		|x_n-x^{\star}|\leqslant\frac{b-a}{2^n}
	\end{equation*}
	因此，可通过给定误差容许值$\varepsilon$，选取满足：
	\begin{equation*}
		\frac{b-a}{2^n}\leqslant\varepsilon
	\end{equation*}
	的最小整数$n$来控制计算精度。
\end{method}
\subsubsection{不动点迭代法}
\begin{method}[Fixed-point Iteration Method]
	为求解非线性方程$f(x)=0$，可将其改写为等价的形式$x=T(x)$，若$T$是一个压缩映射，由\cref{theo:ContractionMapTheorem}可求得非线性方程的根。对于迭代次数问题，可用\cref{theo:ContractionMapTheorem}中的第二种误差估计公式来控制精度。
\end{method}
\begin{definition}
	设映射$T$有不动点$x^{\star}$。若存在$x^{\star}$的邻域$\bar{U}(x^{\star},\delta)$满足对任意的$x\in\bar{U}(x^{\star},\delta)$，序列$\{x_n=T^nx\}\to x^{\star}$，则称此时的迭代法\gls{LocalConvergence}。
\end{definition}
\begin{theorem}\label{theo:FixedPointLocalConvergence}
	设映射$T$有不动点$x^{\star}$，$T'$在$x^{\star}$的某个邻域内连续，且$|T'x^{\star}|<1$，则此时的迭代法局部收敛。
\end{theorem}
\begin{proof}
	由条件和\cref{prop:RSeq}(5)可知存在$x^{\star}$的邻域$U$和$L$，使得对任意的$x\in U$有$|T'x|\leqslant L<1$。根据\cref{theo:LagrangeMeanValueTheorem}可知对任意的$x'\in U$有：
	\begin{equation*}
		|Tx-Tx^{\star}|\leqslant L|x-x^{\star}|
	\end{equation*}
	即$T$在$x^{\star}$的某个闭邻域内是压缩映射，由\cref{theo:RnComplete}、\cref{prop:CompleteMetricSpace}(1)和\cref{theo:ContractionMapTheorem}可知此时的迭代法局部收敛。
\end{proof}
\begin{definition}
	设迭代过程$x_{n+1}=Tx_n$收敛于$T$的不动点$x^{\star}$。令$\varepsilon_n=x_n-x^{\star}$，若有：
	\begin{equation*}
		\lim_{n\to+\infty}\frac{\varepsilon_{n+1}}{\varepsilon_n^p}=C\in\mathbb{R}^{}\setminus\{0\}
	\end{equation*}
	则称该迭代过程是$p$阶收敛的。特别的，$p=1$且$|C|<1$时称为\gls{LinearConvergence}，$p>1$时称为\gls{SuperlinearConvergence}。
\end{definition}
\begin{theorem}\label{theo:FixedPointOrderPConvergence}
	设迭代过程$x_{n+1}=Tx_n$。若对于$p\in\mathbb{N}^+$，$T^{(p)}$在$T$的不动点$x^{\star}$的某个邻域内连续，并且有：
	\begin{equation*}
		T'x^{\star}=T''x^{\star}=\cdots=T^{(p-1)}x^{\star}=0,\;T^{(p)}x^{\star}\ne0
	\end{equation*}
	则该迭代过程在$x^{\star}$邻近是$p$阶收敛的。
\end{theorem}
\begin{proof}
	由$T'x^{\star}=0$和\cref{theo:FixedPointLocalConvergence}可知该迭代过程是局部收敛的。根据\info{泰勒展开Lagrange余项}可得：
	\begin{equation*}
		Tx_n=Tx^{\star}+\frac{T^{(p)}\xi_n}{p!}(x_n-x^{\star})^p,\quad\xi_n\text{在$x_n$与$x^{\star}$之间}
	\end{equation*}
	所以：
	\begin{equation*}
		\frac{Tx_n-x^{\star}}{(x_n-x^{\star})^p}=\frac{T^{(p)}\xi_n}{p!}
	\end{equation*}
	由$T^{(p)}$在$x^{\star}$某个邻域内的连续性和\cref{prop:RSeq}(8.c)(4.a)可得：
	\begin{equation*}
		\lim_{n\to+\infty}\frac{Tx_n-x^{\star}}{(x_n-x^{\star})^p}=\lim_{n\to+\infty}\frac{T^{(p)}\xi_n}{p!}=\frac{1}{p!}T^{(p)}\left(\lim_{n\to+\infty}\xi_n\right)=\frac{T^{(p)}x^{\star}}{p!}\qedhere
	\end{equation*}
\end{proof}
\subsubsection{牛顿法}
\begin{method}[Newton Method]
	设$f$在根$x^{\star}$的某个邻域内是$C^2$类函数，且满足$f(x^{\star})=0,\;f'(x^{\star})\ne0$。为求解非线性方程$f(x)=0$，牛顿法对$f$在当前迭代点$x_n$处作一阶Taylor展开，得到：
	\begin{equation*}
		f(x)\approx f(x_n)+f'(x_n)(x-x_n)
	\end{equation*}
	令上式为$0$得到迭代格式为：
	\begin{equation*}
		x_{n+1}=x_n-\frac{f(x_n)}{f'(x_n)}
	\end{equation*}\par
	牛顿法的迭代函数为：
	\begin{equation*}
		Tx=x-\frac{f(x)}{f'(x)}
	\end{equation*}
	于是有：
	\begin{equation*}
		T'x=1-\frac{[f'(x)]^2-f(x)f''(x)}{[f'(x)]^2}=\frac{f(x)f''(x)}{[f'(x)]^2}
	\end{equation*}
	根据\cref{theo:FixedPointOrderPConvergence}可知牛顿法至少是二阶收敛的。
\end{method}


\paragraph{设定与记号}
固定 \(a>0\)。定义迭代
\[
x_{n+1}=\tfrac12\!\left(x_n+\frac{a}{x_n}\right),\qquad n=0,1,2,\dots
\]
设真值 \(r=\sqrt a>0\)，误差 \(e_n\coloneq x_n-r\)。

\begin{theorem}[Heron 法是 Newton--Raphson 的特例]
	令 \(f(x)=x^2-a\)。对方程 \(f(x)=0\) 应用 Newton 法
	\[
	x_{n+1}=x_n-\frac{f(x_n)}{f'(x_n)}=x_n-\frac{x_n^2-a}{2x_n}
	=\frac12\!\left(x_n+\frac{a}{x_n}\right),
	\]
	即为所给迭代。
\end{theorem}

\begin{theorem}[不变性、单调性与收敛]
	若 \(x_0>0\)，则对所有 \(n\) 都有 \(x_n>0\)。进一步：
	\begin{enumerate}
		\item 若 \(x_0>r\)，则 \(x_{n+1}\in(r,x_n)\)，序列严格单调递减并下有界，极限为 \(r\)。
		\item 若 \(0<x_0<r\)，则 \(x_{n+1}\in(x_n,r)\)，序列严格单调递增并上有界，极限为 \(r\)。
	\end{enumerate}
\end{theorem}

\begin{proof}
	首先 \(x_n>0\Rightarrow x_{n+1}=\frac12(x_n+a/x_n)>0\)，故正性不变。
	
	设 \(x_n>r\)。则
	\[
	x_{n+1}-r=\frac{x_n^2+a}{2x_n}-r
	=\frac{x_n^2-2rx_n+r^2}{2x_n}=\frac{(x_n-r)^2}{2x_n}>0,
	\]
	且
	\[
	x_n-x_{n+1}=x_n-\frac12\!\left(x_n+\frac{a}{x_n}\right)
	=\frac{x_n^2-a}{2x_n}=\frac{(x_n-r)(x_n+r)}{2x_n}>0,
	\]
	故 \(x_{n+1}\in(r,x_n)\) 并单调递减。由下界 \(r\) 与单调性知收敛，极限必为 \(f\) 的正根 \(r\)。
	
	当 \(0<x_n<r\) 时同理得
	\[
	x_{n+1}-r=\frac{(x_n-r)^2}{2x_n}<0,\qquad
	x_{n+1}-x_n=\frac{a-x_n^2}{2x_n}>0,
	\]
	故 \(x_{n+1}\in(x_n,r)\) 并单调递增，极限同为 \(r\)。
\end{proof}

\begin{theorem}[误差精确递推与二次收敛]
	令 \(e_n=x_n-r\)。对任意 \(x_n>0\) 有
	\[
	e_{n+1}=x_{n+1}-r=\frac{(x_n-r)^2}{2x_n}=\frac{e_n^2}{2x_n}.
	\]
	因此当 \(x_n\to r\) 时
	\[
	e_{n+1}=\frac{e_n^2}{2r}\,(1+o(1)),
	\]
	即误差二次收敛，渐近误差常数为 \(1/(2r)\)。
\end{theorem}

\begin{proof}
	代数恒等式直接给出
	\(
	x_{n+1}-r=\frac{(x_n-r)^2}{2x_n}.
	\)
	当 \(x_n\to r>0\) 时，\(\frac{1}{2x_n}\to \frac{1}{2r}\)，得所述渐近式。
\end{proof}

\begin{remark}[相对误差形式]
	相对误差 \(\delta_n\coloneq\frac{x_n-r}{r}\) 满足
	\[
	\delta_{n+1}=\frac{\delta_n^2}{2(1+\delta_n)}=\frac12\delta_n^2+O(\delta_n^3),
	\]
	同样显示二次收敛。
\end{remark}

\begin{theorem}[倒数平方根的牛顿迭代与一次修正]
	为求 \(y=1/\sqrt a\)，考虑
	\(
	\phi(y)=y^{-2}-a=0
	\)。
	Newton 法给出
	\[
	y_{k+1}=y_k-\frac{\phi(y_k)}{\phi'(y_k)}
	=y_k-\frac{y_k^{-2}-a}{-2y_k^{-3}}
	=y_k\!\left(\frac32-\frac{a y_k^2}{2}\right).
	\]
	设初值 \(y_0\) 来自硬件 \texttt{rsqrt} 指令（粗近似）。则该迭代二次收敛到 \(1/\sqrt a\)。
	得到 \(y_m\) 后，可令
	\(
	x=a\,y_m
	\)
	作为 \(\sqrt a\) 的近似；若需再提高精度，对 \(x\) 再做一次 Heron 步
	\[
	x\ \leftarrow\ \frac12\!\left(x+\frac{a}{x}\right),
	\]
	误差继续二次缩小。
\end{theorem}

\begin{proof}
	\(\phi'(y)=-2y^{-3}\neq0\) 于 \(y>0\)。标准 Newton 收敛定理表明在真根邻域二次收敛。误差递推可直接线化得到
	\(
	\varepsilon_{k+1}\approx \tfrac{3}{2}\,a\,\varepsilon_k^2
	\)
	（此处 \(\varepsilon_k\) 为 \(y_k\) 的绝对误差），从而二次收敛。令 \(x=a\,y\) 则
	\(x=\sqrt a\,(1+\eta)\)
	的相对误差与 \(y\) 的相对误差一致；随后的 Heron 一步按前述定理使相对误差平方级下降。
\end{proof}

\begin{corollary}[一次修正的效果评估]
	若 \(\tilde y=\frac{1}{\sqrt a}(1+\epsilon)\) 为倒数平方根的相对误差近似，则
	\(
	\tilde x=a\tilde y=\sqrt a(1+\epsilon)
	\)
	为平方根近似。对 \(\tilde x\) 做一轮 Heron：
	\[
	x^+=\tfrac12\!\left(\tilde x+\frac{a}{\tilde x}\right)
	=\sqrt a\left(1+\frac{\epsilon^2}{2}+O(\epsilon^3)\right),
	\]
	相对误差由 \(O(\epsilon)\) 降为 \(O(\epsilon^2)\)。
\end{corollary}

\section{插值法}
\begin{definition}
	设函数$f$在$[a,b]$上有定义，且已知在点$a\leqslant x_0<x_1<\cdots<x_n\leqslant b$上的值$y_0,y_1,\dots,y_n$。若存在一个简单函数$P(x)$使得：
	\begin{equation*}
		P(x_i)=y_i,\quad i=0,1,\dots,n
	\end{equation*}
	则称$P$为$f$的\gls{InterpolatingFunction}，点$x_0,x_1,\dots,x_n$被称为\gls{InterpolationNodes}，$[a,b]$为\gls{InterpolationInterval}，求插值函数$P$的方法称为\gls{InterpolationMethod}。若$P$是不超过$n$次的多项式，即：
	\begin{equation*}
		P(x)=\sum_{i=0}^{n}a_ix^i,\quad a_i\in\mathbb{R}^{},\;i=0,1,\dots,n
	\end{equation*}
	则称$P$为\gls{InterpolationPolynomial}，对应的插值法被称为\gls{PolynomialInterpolation}。若$P$是分段的多项式，则称对应的插值法为\gls{PiecewiseInterpolation}。
\end{definition}
\begin{theorem}\label{theo:ExistenceUniquenessInterpolationPolynomial}
	设函数$f$在$[a,b]$上有定义，且已知在点$a\leqslant x_0<x_1<\cdots<x_n\leqslant b$上的值$y_0,y_1,\dots,y_n$。$f$在$[a,b]$上次数不超过$n$的插值多项式存在且唯一。
\end{theorem}
\begin{proof}
	设$P(x)=\sum\limits_{i=0}^{n}a_ix^i$，则由条件可得到：
	\begin{equation*}
		\begin{pmatrix}
			1 & x_0 & x_0^2 & \cdots & x_0^n \\
			1 & x_1 & x_1^2 & \cdots & x_1^n \\
			\vdots & \vdots & \vdots & \ddots & \vdots \\
			1 & x_n & x_n^2 & \cdots & x_n^n
		\end{pmatrix}
		\begin{pmatrix}
			a_0 \\
			a_1 \\ 
			\vdots \\ 
			a_n
		\end{pmatrix}
		=
		\begin{pmatrix}
			y_0 \\ 
			y_1 \\ 
			\vdots \\ 
			y_n
		\end{pmatrix}
	\end{equation*}
	根据\cref{prop:Determinant}(13)、\cref{prop:Rank}(1)和\cref{theo:SolutionOfSLE2}(2)可知上述线性方程组的解存在且唯一，即$f$在$[a,b]$上次数不超过$n$的插值多项式存在且唯一。
\end{proof}
\subsubsection{Lagrange插值多项式}
\begin{definition}
	若$n$次多项式$l_i(x),\;i=0,1,\dots,n$在$n+1$个节点$x_0<x_1<\cdots<x_n$上满足：
	\begin{equation*}
		l_i(x_j)=
		\begin{cases}
			1,& i=j \\
			0,& i\ne j
		\end{cases},\quad
		i,j=0,1,\dots,n
	\end{equation*}
	则称$l_0(x),l_1(x),\dots,l_n(x)$为节点$x_0,x_1,\dots,x_n$上的$n$次\gls{InterpolationBasisFunctions}。
\end{definition}
\begin{definition}
	设函数$f$在$[a,b]$上有定义，且已知在点$a\leqslant x_0<x_1<\cdots<x_n\leqslant b$上的值$y_0,y_1,\dots,y_n$。定义：
	\begin{equation*}
		l_i(x)=\frac{(x-x_0)(x-x_1)\dots(x-x_{i-1})(x-x_{i+1})\dots(x-x_n)}{(x_i-x_0)(x_i-x_1)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_n)},\quad i=0,1,\dots,n
	\end{equation*}
	称：
	\begin{equation*}
		L_n(x)\coloneq\sum_{i=0}^{n}y_il_i(x)
	\end{equation*}
	为$f$在节点$x_0,x_1,\dots,x_n$上的\gls{LagrangeInterpolationPolynomial}。
\end{definition}
\begin{property}\label{prop:LagrangeInterpolationPolynomial}
	设函数$f$在$[a,b]$上有定义，且已知在点$a\leqslant x_0<x_1<\cdots<x_n\leqslant b$上的值$y_0,y_1,\dots,y_n$，$f\in C^n([a,b])$，$f^{(n+1)}$在$(a,b)$上存在，$L_n$为$f$在节点$x_0,x_1,\dots,x_n$上的Lagrange插值多项式。$L_n$具有如下性质：
	\begin{enumerate}
		\item 记$w_{n+1}(x)=(x-x_0)(x-x_1)\cdots(x-x_n)$，则：
		\begin{equation*}
			L_n(x)=\sum_{i=0}^{n}y_i\frac{w_{n+1}(x)}{(x-x_i)w_{n+1}'(x_i)}
		\end{equation*}
		\item 对于任意的$x\in[a,b]$，有误差估计：
		\begin{equation*}
			f(x)-L_n(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}w_{n+1}(x)
		\end{equation*}
		其中$\xi\in(a,b)$；
		\item $\sum\limits_{i=0}^{n}x_i^ml_i(x)=x^m(m\leqslant n)$；
		\item $L_n$有如下形式：
		\begin{equation*}
			L_n(x)=\frac{\sum\limits_{i=0}^{n}y_i\dfrac{1}{(x-x_i)w_{n+1}'(x_i)}}{\sum\limits_{i=0}^{n}\dfrac{1}{(x-x_i)w_{n+1}'(x_i)}}
		\end{equation*}
	\end{enumerate}
\end{property}
\begin{proof}
	(1)由\info{乘积的微分}可知：
	\begin{equation*}
		w_{n+1}'(x_i)=(x_i-x_0)(x_i-x_1)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_n)
	\end{equation*}
	于是：
	\begin{equation*}
		l_i(x)=\frac{w_{n+1}(x)}{(x-x_i)w_{n+1}'(x_i)}
	\end{equation*}\par
	(2)由条件可设$f(x)-L_n(x)=K(x)w_{n+1}(x)$，其中$K(x)$是一个待定函数。作辅助函数：
	\begin{equation*}
		\varphi(t)=f(t)-L_n(t)-K(x)w_{n+1}(t)
	\end{equation*}
	由\cref{prop:RMap}(5.b)和\cref{prop:FrechetDifferential}(4)可知$\varphi^{(n)}$在$[a,b]$上连续，$\varphi^{(n+1)}$在$(a,b)$上存在。因为$\varphi$在$x_0,x_1,\dots,x_n$和$x$处均为$0$，所以$\varphi$在$[a,b]$上有$n+2$个零点，根据\cref{prop:RMap}(5.b)、\cref{prop:FrechetDifferential}(4)和\cref{theo:RolleTheorem}可知$\varphi'$在$\varphi$的两个零点间至少存在一个零点，所以$\varphi'$在$[a,b]$上至少存在$n+1$个零点。对$\varphi'$再使用\cref{theo:RolleTheorem}可知$\varphi''$在$[a,b]$上至少存在$n$个零点。依此类推可知$\varphi^{(n+1)}$在$(a,b)$上至少存在一个零点$\xi$，即：
	\begin{equation*}
		\varphi^{(n+1)}(\xi)=f^{(n+1)}(\xi)-K(x)(n+1)!=0
	\end{equation*}
	于是：
	\begin{equation*}
		K(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}
	\end{equation*}
	即：
	\begin{equation*}
		f(x)-L_n(x)=\frac{f^{(n+1)}(\xi)}{(n+1)!}w_{n+1}(x)
	\end{equation*}\par
	(3)设$f=x^m$，由(2)即可得出结论。\par
	(4)在(3)中取$m=0$，由(1)(3)可得：
	\begin{equation*}
		1=\sum_{i=0}^{n}l_i(x)=\sum_{i=0}^{n}\frac{w_{n+1}(x)}{(x-x_i)w_{n+1}'(x_i)}=w_{n+1}(x)\sum_{i=0}^{n}\frac{1}{(x-x_i)w_{n+1}'(x_i)}
	\end{equation*}
	所以：
	\begin{equation*}
		w_{n+1}(x)=\frac{1}{\sum\limits_{i=0}^{n}\dfrac{1}{(x-x_i)w_{n+1}'(x_i)}}
	\end{equation*}
	于是有：
	\begin{align*}
		L_n(x)&=\sum_{i=0}^{n}y_i\frac{w_{n+1}(x)}{(x-x_i)w_{n+1}'(x_i)}=w_{n+1}(x)\sum_{i=0}^{n}y_i\frac{1}{(x-x_i)w_{n+1}'(x_i)} \\
		&=\frac{\sum\limits_{i=0}^{n}y_i\dfrac{1}{(x-x_i)w_{n+1}'(x_i)}}{\sum\limits_{i=0}^{n}\dfrac{1}{(x-x_i)w_{n+1}'(x_i)}}\qedhere
	\end{align*}
\end{proof}
\begin{note}
	\cref{prop:LagrangeInterpolationPolynomial}(4)中$L_n$的形式又被称为\textbf{Barycentric形式}。该表示形式在数学上与拉格朗日插值多项式完全等价，但在数值计算中避免了高次多项式乘积的显式计算，即计算：
	\begin{equation*}
		w_{n+1}(x)=(x-x_0)(x-x_1)\cdots(x-x_n)
	\end{equation*}
	从而减少了由大数乘积和相消所引起的数值误差，具有显著更优的稳定性。基于上述原因，在实际数值计算中通常优先采用Barycentric形式来实现多项式插值。
\end{note}
\begin{minted}[linenos,breaklines]{python}
    import numpy as np
    from scipy.interpolate import BarycentricInterpolator
    x_nodes = np.array([0.0,1.0,2.0,3.0])
    y_nodes = np.array([1.0,2.0,0.0,5.0])
    interp = BarycentricInterpolator(x_nodes,y_nodes)
    print(interp(1.5))
\end{minted}
\subsubsection{Newton插值多项式}
\begin{definition}
	设函数$f$在$[a,b]$上有定义，$a\leqslant x_0<x_1<\cdots<x_n\leqslant b$。记$f[x_0]=f(x_0)$，称：
	\begin{equation*}
		f[x_0,x_n]=\frac{f(x_n)-f(x_0)}{x_n-x_0}
	\end{equation*}
	为$f$关于点$x_0,x_n$的\gls{FirstOrderDividedDifference}。称：
	\begin{equation*}
		f[x_0,x_1,\dots,x_n]=\frac{f[x_1,x_2,\dots,x_n]-f[x_0,x_1,\dots,x_{n-1}]}{x_n-x_0}
	\end{equation*}
	为$f$的\gls{NthOrderDividedDifference}。
\end{definition}
\begin{property}\label{prop:DividedDifference}
	设函数$f$在$[a,b]$上有定义，$a\leqslant x_0<x_1<\cdots<x_n\leqslant b$。均差具有如下性质：
	\begin{enumerate}
		\item $f$的$n$阶均差可以表示为$f(x_0),f(x_1),\dots,f(x_n)$的线性组合：
		\begin{equation*}
			f[x_0,x_1,\dots,x_n]=\sum_{i=0}^{n}\frac{f(x_i)}{(x_i-x_0)(x_i-x_1)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_n)}
		\end{equation*}
		\item $f[x_0,x_1,\dots,x_n]$对$\{x_0,x_1,\dots,x_n\}$的任意顺序置换保持不变；
		\item 对任意的$\alpha,\beta\in\mathbb{R}^{}$和$[a,b]$上的函数$g$，有：
		\begin{equation*}
			(\alpha f+\beta g)[x_0,x_1,\dots,x_n]=\alpha f[x_0,x_1,\dots,x_n]+\beta g[x_0,x_1,\dots,x_n]
		\end{equation*}
		\item 若$f\in C^n([a,b])$，则存在$\xi\in[a,b]$使得：
		\begin{equation*}
			f[x_0,x_1,\dots,x_n]=\frac{f^{(n)}(\xi)}{n!}
		\end{equation*}
	\end{enumerate}
\end{property}
\begin{proof}
	(1)使用数学归纳法。当$n=1$时有：
	\begin{equation*}
		f[x_0,x_1]=\frac{f(x_1)-f(x_0)}{x_1-x_0}=\frac{f(x_0)}{x_0-x_1}+\frac{f(x_1)}{x_1-x_0}
	\end{equation*}
	结论成立。设结论对$n-1$成立，下面证明结论对$n$也成立。\par
	根据归纳假设：
	\begin{align*}
		&f[x_0,x_1,\dots,x_n]=\frac{f[x_1,x_2,\dots,x_n]-f[x_0,x_1,\dots,x_{n-1}]}{x_n-x_0} \\
		=&\frac{1}{x_n-x_0}\left[\sum_{i=1}^{n}\frac{f(x_i)}{(x_i-x_1)(x_i-x_2)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_n)}\right. \\
		&\left.-\sum_{i=0}^{n-1}\frac{f(x_i)}{(x_i-x_0)(x_i-x_1)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_{n-1})}\right]  \\
		=&\frac{f(x_n)}{(x_n-x_0)(x_n-x_1)\dots(x_n-x_{n-1})}+\frac{f(x_0)}{(x_0-x_1)(x_0-x_2)\dots(x_0-x_n)} \\
		&+\sum_{i=1}^{n-1}\left[\frac{f(x_i)}{(x_n-x_0)(x_i-x_1)(x_i-x_2)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_n)}\right. \\
		&\left.-\frac{f(x_i)}{(x_n-x_0)(x_i-x_0)(x_i-x_1)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_{n-1})}\right]
	\end{align*}
	对于最后一项：
	\begin{align*}
		&\sum_{i=1}^{n-1}\left[\frac{(x_i-x_0)f(x_i)}{(x_n-x_0)(x_i-x_0)(x_i-x_1)(x_i-x_2)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_n)}\right. \\
		&\left.-\frac{(x_i-x_n)f(x_i)}{(x_n-x_0)(x_i-x_0)(x_i-x_1)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_{n-1})(x_i-x_n)}\right] \\
		=&\sum_{i=1}^{n-1}\frac{(x_i-x_0)f(x_i)-(x_i-x_n)f(x_i)}{(x_n-x_0)(x_i-x_0)(x_i-x_1)(x_i-x_2)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_n)} \\
		=&\sum_{i=1}^{n-1}\frac{(x_n-x_0)f(x_i)}{(x_n-x_0)(x_i-x_0)(x_i-x_1)(x_i-x_2)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_n)} \\
		=&\sum_{i=1}^{n-1}\frac{f(x_i)}{(x_i-x_0)(x_i-x_1)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_n)}
	\end{align*}
	所以结论成立。\par
	(2)由(1)立即可得。\par
	(3)由(1)立即可得。\par
	(4)令$L_{n-1}$为$f$在节点$x_0,x_1,\dots,x_{n-1}$上的Lagrange插值多项式，作辅助函数：
	\begin{equation*}
		\varphi(x)=f(x)-L_{n-1}(x)-f[x_0,x_1,\dots,x_n]w_n(x)
	\end{equation*}
	由$L_{n-1}$的定义可知$f-L_{n-1}$在节点$x_0,x_1,\dots,x_{n-1}$上为$0$，而$w_n$在节点$x_0,x_1,\dots,x_{n-1}$上为$0$，所以$x_0,x_1,\dots,x_{n-1}$是$\varphi$的零点。注意到：
	\begin{align*}
		&f(x_n)-L_{n-1}(x_n)-f[x_0,x_1,\dots,x_n]w_n(x_n) \\
		=&f(x_n)-\sum_{i=0}^{n-1}\frac{f(x_i)(x_n-x_0)(x_n-x_1)\dots(x_n-x_{i-1})(x_n-x_{i+1})\dots(x_n-x_{n-1})}{(x_i-x_0)(x_i-x_1)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_{n-1})} \\
		&-\sum_{i=0}^{n}\frac{f(x_i)(x_n-x_0)(x_n-x_1)\cdots(x_n-x_{n-1})}{(x_i-x_0)(x_i-x_1)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_n)} \\
		=&f(x_n)-\sum_{i=0}^{n-1}\frac{f(x_i)(x_n-x_0)(x_n-x_1)\dots(x_n-x_{i-1})(x_n-x_{i+1})\dots(x_n-x_{n-1})}{(x_i-x_0)(x_i-x_1)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_{n-1})} \\
		&-f(x_n)-\sum_{i=0}^{n-1}\frac{f(x_i)(x_n-x_0)(x_n-x_1)\cdots(x_n-x_{n-1})}{(x_i-x_0)(x_i-x_1)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_n)} \\
		=&-\sum_{i=0}^{n-1}\frac{f(x_i)(x_n-x_0)(x_n-x_1)\dots(x_n-x_{n-1})}{(x_i-x_0)(x_i-x_1)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_{n-1})(x_n-x_i)} \\
		&-\sum_{i=0}^{n-1}\frac{f(x_i)(x_n-x_0)(x_n-x_1)\cdots(x_n-x_{n-1})}{(x_i-x_0)(x_i-x_1)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_n)}=0
	\end{align*}
	所以$x_n$也是$\varphi$的零点。根据\cref{prop:RMap}(5.b)、\cref{prop:FrechetDifferential}(4)和\cref{theo:RolleTheorem}可知$\varphi'$在$[a,b]$上存在$n$个零点。对$\varphi'$再使用\cref{theo:RolleTheorem}可知$\varphi''$在$[a,b]$上存在$n-1$个零点。依此类推可知$\varphi^{(n)}$在$[a,b]$上存在一个零点$\xi$，即：
	\begin{equation*}
		\varphi^{(n)}(\xi)=f^{(n)}(\xi)-f[x_0,x_1,\dots,x_n]n!=0
	\end{equation*}
	所以：
	\begin{equation*}
		f[x_0,x_1,\dots,x_n]=\frac{f^{(n)}(\xi)}{n!}\qedhere
	\end{equation*}
\end{proof}
\begin{definition}
	设函数$f$在$[a,b]$上有定义，且已知在点$a\leqslant x_0<x_1<\cdots<x_n\leqslant b$上的值$y_0,y_1,\dots,y_n$。称：
	\begin{equation*}
		P_n(x)=f[x_0]+f[x_0,x_1](x-x_0)+f[x_0,x_1,x_2](x-x_0)(x-x_1)+\cdots+f[x_0,x_1,\dots,x_n]\prod_{i=0}^{n-1}(x-x_i)
	\end{equation*}
	为$f$在节点$x_0,x_1,\dots,x_n$上的\gls{NewtonInterpolationPolynomial}。
\end{definition}
\begin{property}\label{prop:NewtonInterpolationPolynomial}
	Newton插值多项式与Lagrange插值多项式等价。
\end{property}
\begin{proof}
	设函数$f$在$[a,b]$上有定义，且已知在点$a\leqslant x_0<x_1<\cdots<x_n\leqslant b$上的值$y_0,y_1,\dots,y_n$。因为$f$在节点$x_0,x_1,\dots,x_n$上的Newton插值多项式$P_n$的次数不超过$n$，根据\cref{theo:ExistenceUniquenessInterpolationPolynomial}只需证明$P_n(x_i)=f(x_i),\;i=0,1,\dots,n$。\par
	使用数学归纳法。当$i=0$时由$P_n$的定义可知$P_n(x_0)=f(x_0)$，设结论对$n-1$成立，下面证明结论对$n$也成立。\par
	对于：
	\begin{equation*}
		P_n(x)=P_{n-1}(x)+f[x_0,x_1,\dots,x_n]w_n(x)
	\end{equation*}
	因为对任意的$i=0,1,\dots,n-1$有$w_n(x_i)=0$，所以由归纳假设可知：
	\begin{equation*}
		P_n(x_i)=P_{n-1}(x_i)=f(x_i),\quad i=0,1,\dots,n-1
	\end{equation*}
	下面证明$P_n(x_n)=f(x_n)$。\par
	作辅助函数$R(x)=f(x)-P_{n-1}(x)$，于是有：
	\begin{equation*}
		\frac{R(x_n)}{w_n(x_n)}=\frac{f(x_n)-P_{n-1}(x_n)}{w_n(x_n)}
	\end{equation*}
	由\cref{prop:DividedDifference}(1)可得：
	\begin{equation*}
		R[x_0,x_1,\dots,x_n]=\sum_{i=0}^{n}\frac{R(x_i)}{(x_i-x_0)(x_i-x_1)\dots(x_i-x_{i-1})(x_i-x_{i+1})\dots(x_i-x_n)}=\frac{R(x_n)}{w_n(x_n)}
	\end{equation*}
	所以：
	\begin{equation*}
		\frac{f(x_n)-P_{n-1}(x_n)}{w_n(x_n)}=R[x_0,x_1,\dots,x_n]
	\end{equation*}
	根据\cref{prop:DividedDifference}(3)可知：
	\begin{equation*}
		R[x_0,x_1,\dots,x_n]=f[x_0,x_1,\dots,x_n]-P_{n-1}[x_0,x_1,\dots,x_n]
	\end{equation*}
	因为$P_{n-1}$的次数不超过$n-1$，由\cref{prop:DividedDifference}(4)可知$P_{n-1}[x_0,x_1,\dots,x_n]=0$，于是有：
	\begin{equation*}
		R[x_0,x_1,\dots,x_n]=f[x_0,x_1,\dots,x_n]
	\end{equation*}
	所以：
	\begin{equation*}
		\frac{f(x_n)-P_{n-1}(x_n)}{w_n(x_n)}=f[x_0,x_1,\dots,x_n]
	\end{equation*}
	即：
	\begin{equation*}
		P_{n-1}(x_n)=f(x_n)-f[x_0,x_1,\dots,x_n]w_n(x_n)
	\end{equation*}
	于是：
	\begin{equation*}
		P_n(x_n)=P_{n-1}(x_n)+f[x_0,x_1,\dots,x_n]w_n(x_n)=f(x_n)\qedhere
	\end{equation*}
\end{proof}
\begin{note}
	根据\cref{prop:NewtonInterpolationPolynomial}，Newton插值多项式和Lagrange插值多项式是等价的，于是它具有了Lagrange插值多项式的全部性质。既然等价，那为什么要研究它呢？\par
	从构造方式看，Lagrange插值是一次性使用全部节点进行整体构造，而Newton插值具有天然的递推性。当新增插值节点时，Lagrange插值多项式通常需要重新计算，而Newton插值多项式只需增加一个新的均差项即可完成更新，这使其在逐点插值与在线计算中具有明显优势。
\end{note}
\subsubsection{Hermite插值}
\begin{definition}
	设函数$f$在$[a,b]$上有定义，且已知$f^{(j)}(x_i)$，$i=0,1,\dots,n,\;j=0,1,\dots,m_i$，其中$a\leqslant x_0<x_1<\cdots<x_n\leqslant b$。令$N=\sum\limits_{i=0}^{n}m_i-1$，称满足：
	\begin{equation*}
		H^{(j)}_N(x_i)=f^{(j)}(x_i),\quad i=0,1,\dots,n,\;j=0,1,\dots,m_i
	\end{equation*}
	的不超过$N$次的多项式$H_N(x)$为\gls{HermiteInterpolationPolynomial}。
\end{definition}
\begin{definition}
	定义：
	\begin{equation*}
		f[\underbrace{x,x,\dots,x}_{n+1\text{个}x}]\coloneq\frac{f^{(n)}(x)}{n!}
	\end{equation*}
\end{definition}
\begin{property}\label{prop:HermiteInterpolationPolynomial}
	设函数$f$在$[a,b]$上有定义，且已知$f^{(j)}(x_i)$，$i=0,1,\dots,n,\;j=0,1,\dots,m_i$，其中$a\leqslant x_0<x_1<\cdots<x_n\leqslant b$，$N=\sum\limits_{i=0}^{n}m_i-1$。Hermite插值多项式具有如下性质：
	\begin{enumerate}
		\item Hermite插值多项式存在且唯一；
		\item 若将每个节点$x_i$重复$m_i+1$次，按重复顺序排列为$y_0,y_1,\dots,y_M$，则：
		\begin{equation*}
			H_N(x)=f[y_0]+f[y_0,y_1](x-y_0)+\cdots+f[y_0,y_1,\dots,y_M]\prod_{i=0}^{M-1}(x-y_i)
		\end{equation*}
	\end{enumerate}
\end{property}
%\begin{proof}
%	设$H_N(x)=a_0+a_1x+a_2x^2+\cdots+a_Nx^N$，则$H_N$满足：
%	\begin{equation*}
%		\begin{pmatrix}
%			1 & x_0 & x_0^2 & \cdots & x_0^N \\
%			0 & 1 & 2x_0 & \cdots & N x_0^{N-1} \\
%			\vdots & \vdots & \vdots & \ddots & \vdots \\
%			0 & 0 & \cdots & \cdots & \dfrac{N!}{(N-m_0)!}x_0^{N-m_0} \\[0.4em]
%			\vdots & \vdots &  &  & \vdots \\[0.4em]
%			1 & x_n & x_n^2 & \cdots & x_n^N \\
%			0 & 1 & 2x_n & \cdots & N x_n^{N-1} \\
%			\vdots & \vdots & \vdots & \ddots & \vdots \\
%			0 & 0 & \cdots & \cdots & \dfrac{N!}{(N-m_n)!}x_n^{N-m_n}
%		\end{pmatrix}
%		\begin{pmatrix}
%			a_0 \\ a_1 \\ \vdots \\ a_N
%		\end{pmatrix}
%		=
%		\begin{pmatrix}
%			f(x_0) \\
%			f'(x_0) \\
%			\vdots \\
%			f^{(m_0)}(x_0) \\
%			\vdots \\
%			f(x_n) \\
%			f'(x_n) \\
%			\vdots \\
%			f^{(m_n)}(x_n)
%		\end{pmatrix}
%	\end{equation*}
%	由Hermite–Vandermonde矩阵行列式非零
%\end{proof}
\begin{minted}[breaklines,linenos]{python}
    import numpy as np
    from scipy.interpolate import KroghInterpolator
    # Hermite interpolation data
    # f(0) = 1, f'(0) = 0
    # f(1) = 2, f'(1) = -1
    x = np.array([0.0, 0.0, 1.0, 1.0])
    y = np.array([1.0, 0.0, 2.0, -1.0])
    # Hermite interpolation
    hermite_poly = KroghInterpolator(x, y)
    # evaluate
    x_eval = np.linspace(0.0, 1.0, 100)
    y_eval = hermite_poly(x_eval)
    print(hermite_poly(0.5))
\end{minted}

%\section{EM算法}
%
%在数理统计中，参数估计问题通常建立在如下概率模型之上：设$(X,\mathcal{A},\mathscr{P})$为可控参数结构，$\Theta$是参数空间，$\seq{X}{n}$是$X$的一个样本，然后通过极大似然估计来构造参数$\theta$的估计量。\par
%但在大量统计模型中，样本并非直接来自一个“完全”概率机制，
%而是某个更高维随机结构的部分观测结果。
%\begin{definition}
%	设$(Y,\mathscr{B})$是一个可测空间，$(X\times Y,\sigma(\mathcal{A}\times\mathcal{B}),\mathscr{P})$为可控参数结构，$\Theta$为参数空间，$f_X,f_Y$分别是$(X,\mathscr{A})$和$(Y,\mathscr{B})$上的随机变量，$f_X$可观测而$f_Y$不可观测，称这类问题为\gls{IncompleteDataProblem}。
%\end{definition}
%\begin{note}
%	在不完全数据问题下，观测数据$\mathbf{X}$的对数似然函数具有如下形式：
%	\begin{equation}
%		\ell(\theta,\mathbf{X})
%		= \log\int p_\theta(\mathbf{X},\mathbf{Y})\dif\mathbf{Y}
%	\end{equation}
%	由于积分运算位于对数函数内部，该目标函数在一般情形下既不具有解析形式，也往往缺乏良好的凸性或可分解结构，从而使得直接的极大似然估计在理论分析与数值计算上都面临显著困难。\par
%	与此形成鲜明对比的是，若观测数据对潜变量$\mathbf{Y}$可被观测，
%	则所谓的\textbf{完全数据对数似然}
%	\begin{equation}
%		\log p_\theta(Y,Z)
%	\end{equation}
%	通常具有更为简单且结构化的形式。
%	在许多重要统计模型中，
%	完全数据模型属于指数族，
%	其极大似然估计可通过充分统计量或标准优化方法得到。
%	因此，不完全数据问题的核心困难并不来源于模型本身，
%	而是来源于对潜变量的不可观测性。
%\end{note}